<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>JumpScale.core.baseclasses.BaseEnumeration &mdash; Jumpscale Doc 7.0 documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '7.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <link rel="top" title="Jumpscale Doc 7.0 documentation" href="../../../../index.html" />
    <link rel="up" title="JumpScale.core.baseclasses" href="../baseclasses.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="../../../../index.html">Jumpscale Doc 7.0 documentation</a> &raquo;</li>
          <li><a href="../../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../baseclasses.html" accesskey="U">JumpScale.core.baseclasses</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for JumpScale.core.baseclasses.BaseEnumeration</h1><div class="highlight"><pre>
<span class="sd">&#39;&#39;&#39;Base Enumeration type implementation</span>

<span class="sd">Enumeration lifecycle</span>
<span class="sd">=====================</span>
<span class="sd">Since the BaseEnumeration type implementation in the following 270 lines of code</span>
<span class="sd">(maybe more at the time you read this) can be non-obvious at first sight,</span>
<span class="sd">here&#39;s an overview of the lifecycle of an enumeration, several pitfalls and</span>
<span class="sd">how we get around them.</span>

<span class="sd">Enumeration definition</span>
<span class="sd">----------------------</span>
<span class="sd">Enumerations are ordinary classes which got the L{BaseEnumeration} class as base.</span>
<span class="sd">The BaseEnumeration class itself provides not much functionality, next to basic</span>
<span class="sd">implementations of __str__ and __repr__, a check method which checks whether</span>
<span class="sd">a given variable is a valid enumeration item (cfr check methods on other</span>
<span class="sd">pmtype classes), and a generic getByName method which retrieves an enumeration</span>
<span class="sd">item based on its name.</span>

<span class="sd">The hard labour is performed by the custom metaclass of BaseEnumeration,</span>
<span class="sd">BaseEnumerationMeta.</span>

<span class="sd">BaseEnumerationMeta magic</span>
<span class="sd">-------------------------</span>
<span class="sd">This class behaves like any other metaclass, generating types from a class.</span>
<span class="sd">Once the type is created, 2 classmethods are added to it, by using a function</span>
<span class="sd">generator: registerItem (generated by generateRegisterItem) and</span>
<span class="sd">finishItemRegistration (generated by generateFinishItemRegistration). These are</span>
<span class="sd">added per-type and not on the BaseEnumeration base type, since we want to be able</span>
<span class="sd">to remove them from types once the type finishItemRegistration is called. If</span>
<span class="sd">the methods would be defined in the BaseEnumeration base type, we would not be able</span>
<span class="sd">to remove them from actual enumeration types (subclasses) unless removing them</span>
<span class="sd">from the BaseEnumeration base class, which would result in a situation where the</span>
<span class="sd">methods are no longer available on any BaseEnumeration subclasses.</span>

<span class="sd">Next to type generation, we cache all generated types, using the full path of</span>
<span class="sd">the module they are defined in (minus extension) and the type name as key. We</span>
<span class="sd">strip the extension because it is possible a type is initially loaded from (eg)</span>
<span class="sd">/foo/bar.py and later on (in the same process) from /foo/bar.pyc, since the</span>
<span class="sd">Python interpreter will generate the precompiled pyc file when the source file</span>
<span class="sd">is loaded the first time, using this one later on.</span>

<span class="sd">Lazy loading pitfalls and type caching</span>
<span class="sd">--------------------------------------</span>
<span class="sd">It might sound strange types should be cached: once a module is loaded into the</span>
<span class="sd">Python process, types defined in it should be generated, registered, and used</span>
<span class="sd">later on, right?</span>

<span class="sd">Well, in a normal application this is the way it&#39;s supposed to work. Inside</span>
<span class="sd">jumpscale we got one extra catch though: lazy-loading of extensions.</span>

<span class="sd">When an extension is lazy-loaded, this is done using the load_module function</span>
<span class="sd">of the built-in imp module. This results in a complete reload of the module and</span>
<span class="sd">any (directly or indirectly) imported module. This results in a recreation of</span>
<span class="sd">all types as well (ie the already registered types are not reused). In normal</span>
<span class="sd">situations this is not an issue, except here, since in the &#39;check&#39; method of</span>
<span class="sd">BaseEnumeration we use an &#39;is&#39; comparison.</span>

<span class="sd">We can get around this by caching all types we create in our metaclass, based</span>
<span class="sd">on definition module and name of the class.</span>

<span class="sd">When even caching becomes complicated</span>
<span class="sd">-------------------------------------</span>
<span class="sd">Caching our types resolves the issue presented in the previous section. More</span>
<span class="sd">problems arise though. If we defined an enumeration once, registered one or</span>
<span class="sd">more items, and called finishItemRegistration, the registerItem and</span>
<span class="sd">finishItemRegistration methods (attributes) are no longer available on the</span>
<span class="sd">type. When we load an extension using the same enumeration (importing the</span>
<span class="sd">module where the enumeration is defined once again), the existing type will be</span>
<span class="sd">returned when the enumeration class is parsed, returning the type which no</span>
<span class="sd">longer got registerItem and finishItemRegistration attributes. In the</span>
<span class="sd">enumeration definition module, there will most likely be calls to the</span>
<span class="sd">registerItem and finishItemRegistration methods (ie the same code which created</span>
<span class="sd">all items initially). This implies we need to re-add the necessary methods to</span>
<span class="sd">the enumeration class.</span>

<span class="sd">We do this by adding a registerItem callable which does nothing at all, and a</span>
<span class="sd">new finishItemRegistration method as generated by</span>
<span class="sd">generateFinishItemRegistration.</span>

<span class="sd">The story of intermediate classes</span>
<span class="sd">---------------------------------</span>
<span class="sd">One more item to tackle: &#39;intermediate classes&#39;. An intermediate enumeration</span>
<span class="sd">is a subclass of BaseEnumeration which represents no actual object by itself, but</span>
<span class="sd">should be subclassed by real enumerations, only providing some extra</span>
<span class="sd">functionality (eg EnumerationWithValue). We do not want to be able to register</span>
<span class="sd">items on these classes, so we don&#39;t add registerItem or finishItemRegistration</span>
<span class="sd">methods to these classes, which can be identified by a special class attribute</span>
<span class="sd">they should set, C{_INTERMEDIATE_CLASS}.</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">keyword</span>
<span class="kn">from</span> <span class="nn">JumpScale</span> <span class="kn">import</span> <span class="n">j</span>

<span class="n">IDENTIFIER_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&#39;^[a-zA-Z_][a-zA-Z0-9_]*$&#39;</span><span class="p">)</span>

<span class="c">#TODO This could become a more general function</span>
<span class="k">def</span> <span class="nf">isValidIdentifier</span><span class="p">(</span><span class="n">identifier</span><span class="p">):</span>
<div class="viewcode-block" id="isValidIdentifier"><a class="viewcode-back" href="../../../../API/JumpScale.core.baseclasses.html#JumpScale.core.baseclasses.BaseEnumeration.isValidIdentifier">[docs]</a>    <span class="sd">&#39;&#39;&#39;Check whether a given string is a valid Python identifier (variable name)</span>

<span class="sd">    In several places (when using user-provided names to create properties or</span>
<span class="sd">    attributes) we should be able to alert the user when attempting to use an</span>
<span class="sd">    invalid identifier, as defined by the Python grammar.</span>

<span class="sd">    This method checks names against the grammar snippet specified in the</span>
<span class="sd">    Python language reference (http://docs.python.org/ref/identifiers.html).</span>

<span class="sd">    It also filters out keywords.</span>

<span class="sd">    @param identifier: Identifier to check</span>
<span class="sd">    @type identified: string</span>

<span class="sd">    @returns: Whether or not the provided identifier is valid</span>
<span class="sd">    @rtype: bool</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">IDENTIFIER_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">identifier</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">if</span> <span class="n">keyword</span><span class="o">.</span><span class="n">iskeyword</span><span class="p">(</span><span class="n">identifier</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">return</span> <span class="bp">True</span>
<span class="k">class</span> <span class="nc">_EnumerationContainer</span><span class="p">:</span></div>
    <span class="sd">&#39;&#39;&#39;Dummy container class to expose enumerations on q&#39;&#39;&#39;</span>

<span class="n">enumerations</span> <span class="o">=</span> <span class="n">_EnumerationContainer</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">JSModelEnumerationContainer</span><span class="p">:</span>
<div class="viewcode-block" id="JSModelEnumerationContainer"><a class="viewcode-back" href="../../../../API/JumpScale.core.baseclasses.html#JumpScale.core.baseclasses.BaseEnumeration.JSModelEnumerationContainer">[docs]</a>    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dummy object to store the JSModel enumerators on it </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>
<span class="n">JSModelEnumerators</span> <span class="o">=</span><span class="nb">dict</span><span class="p">()</span></div>


<span class="k">def</span> <span class="nf">generateRegisterItem</span><span class="p">():</span>
<div class="viewcode-block" id="generateRegisterItem"><a class="viewcode-back" href="../../../../API/JumpScale.core.baseclasses.html#JumpScale.core.baseclasses.BaseEnumeration.generateRegisterItem">[docs]</a>    <span class="sd">&#39;&#39;&#39;Generate an C{BaseEnumeration.registerItem} method</span>

<span class="sd">    We need this external generator so we can add the registerItem method to</span>
<span class="sd">    subclasses of BaseEnumeration in their metaclass.</span>

<span class="sd">    We need to set the methods per subclass, otherwise we can&#39;t delete the method</span>
<span class="sd">    attribute from the class when the consumer calls C{finishItemRegistration}.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">registerItem</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">itemname</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Register a new item in the enumeration</span>

<span class="sd">        The C{itemname} argument will be uppercased and become the class</span>
<span class="sd">        attribute name.</span>
<span class="sd">        *args and **kwargs are passed to the class constructor as-is.</span>

<span class="sd">        @param itemname: name of enumeration item, will be uppercased</span>
<span class="sd">        @type itemname: string</span>
<span class="sd">        @param *args: arguments passed to class constructor</span>
<span class="sd">        @param **kwargs: arguments passed to class constructor</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">attrname</span> <span class="o">=</span> <span class="n">itemname</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="sd">&#39;&#39;&#39;Name of the attribute on the class this instance will be bound to&#39;&#39;&#39;</span>

        <span class="c">#Check whether this is a valid identifier, ie can we use it as</span>
        <span class="c">#attribute name</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isValidIdentifier</span><span class="p">(</span><span class="n">attrname</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;The given item name </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s"> is not a valid identifier when converted to attribute name </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s">. It should be a valid Python identifier&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">itemname</span><span class="p">,</span> <span class="n">attrname</span><span class="p">))</span>

        <span class="n">instance</span> <span class="o">=</span> <span class="n">cls</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="sd">&#39;&#39;&#39;Class instance to use in the enumeration&#39;&#39;&#39;</span>
        <span class="c">#if not hasattr(cls, &#39;_pm_name2level&#39;):</span>
            <span class="c">#cls._pm_name2level = dict()            </span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="s">&#39;_pm_level2name&#39;</span><span class="p">):</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">_pm_level2name</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">instance</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&quot;level&quot;</span><span class="p">):</span>
            <span class="c">#cls._pm_name2level[itemname] = instance.level</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">_pm_level2name</span><span class="p">[</span><span class="n">instance</span><span class="o">.</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">instance</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="s">&#39;_pm_enumeration_items&#39;</span><span class="p">):</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">_pm_enumeration_items</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="sd">&#39;&#39;&#39;Holder for instances, used by getByName&#39;&#39;&#39;</span>

        <span class="n">cls</span><span class="o">.</span><span class="n">_pm_enumeration_items</span><span class="p">[</span><span class="n">itemname</span><span class="p">]</span> <span class="o">=</span> <span class="n">instance</span>

        <span class="c">#Internal, used for filtering in jshell</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&#39;_pm_enumeration_hidden&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s">&#39;_pm_enumeration_name&#39;</span><span class="p">,</span> <span class="n">itemname</span><span class="p">)</span>

        <span class="c">#Set attribute on class</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">attrname</span><span class="p">,</span> <span class="n">instance</span><span class="p">)</span>

    <span class="c">#Internal, used for filtering in jshell</span>
    <span class="c">#This removes MyEnu.FOO.registerItem, since this should not be visible</span>
    <span class="n">registerItem</span><span class="o">.</span><span class="n">_pm_enumeration_hidden</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">return</span> <span class="n">registerItem</span>


<span class="k">def</span> <span class="nf">generateFinishItemRegistration</span><span class="p">():</span></div>
<div class="viewcode-block" id="generateFinishItemRegistration"><a class="viewcode-back" href="../../../../API/JumpScale.core.baseclasses.html#JumpScale.core.baseclasses.BaseEnumeration.generateFinishItemRegistration">[docs]</a>    <span class="sd">&#39;&#39;&#39;Generate an C{BaseEnumeration.finishItemRegistration} method</span>

<span class="sd">    We need this external generator so we can add the finishItemRegistration</span>
<span class="sd">    method to subclasses of BaseEnumeration in their metaclass.</span>

<span class="sd">    We need to set the methods per subclass, otherwise we can&#39;t del the method</span>
<span class="sd">    attribute from the class when the consumer calls finishItemRegistration.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">finishItemRegistration</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Finish item registration</span>

<span class="sd">        Call this method when all enumeration items are created and no more</span>
<span class="sd">        should be creatable.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="sd">&#39;&#39;&#39;Custom constructor which disables further instance creation&#39;&#39;&#39;</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;No more </span><span class="si">%s</span><span class="s"> instances should be created, it</span><span class="se">\&#39;</span><span class="s">s a finished enumeration&#39;</span> <span class="o">%</span> <span class="n">cls</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>

        <span class="c">#Overwrite the class constructor to one which errors out</span>
        <span class="c">#This way no further instances of the enumeration type, next to the</span>
        <span class="c">#registered ones, can be created.</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">__init__</span> <span class="o">=</span> <span class="n">__init__</span>

        <span class="c">#Remove the finishItemRegistration and registerItem methods from the</span>
        <span class="c">#class and its instances</span>
        <span class="k">del</span> <span class="n">cls</span><span class="o">.</span><span class="n">finishItemRegistration</span>
        <span class="k">del</span> <span class="n">cls</span><span class="o">.</span><span class="n">registerItem</span>

    <span class="c">#Internal, used for filtering in jshell</span>
    <span class="n">finishItemRegistration</span><span class="o">.</span><span class="n">_pm_enumeration_hidden</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">return</span> <span class="n">finishItemRegistration</span>


<span class="k">class</span> <span class="nc">BaseEnumerationMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span></div>
<div class="viewcode-block" id="BaseEnumerationMeta"><a class="viewcode-back" href="../../../../API/JumpScale.core.baseclasses.html#JumpScale.core.baseclasses.BaseEnumeration.BaseEnumerationMeta">[docs]</a>    <span class="sd">&#39;&#39;&#39;Meta class for BaseEnumeration and its subclasses</span>

<span class="sd">    Why do we need this?</span>
<span class="sd">    --------------------</span>
<span class="sd">    We want to be able to remove the registerItem and finishItemRegistration</span>
<span class="sd">    methods from subclasses of BaseEnumeration at runtime, more precisely after</span>
<span class="sd">    finishItemRegistration on a subclass is called.</span>

<span class="sd">    These methods are attributes at class-level (ie. on the enumeration</span>
<span class="sd">    subclass or one of its parents).</span>

<span class="sd">    We can not place the methods in the BaseEnumeration class (which would be more</span>
<span class="sd">    logical), because if we&#39;d put it there, removing the desired methods from</span>
<span class="sd">    subclasses won&#39;t work, because they are not attributes on the actual</span>
<span class="sd">    subclass (they are attributes on the parent Enumeration class). We could</span>
<span class="sd">    obviously remove them from the parent BaseEnumeration class, but then, all at</span>
<span class="sd">    once, the method would be completely gone on _any_ subclass of BaseEnumeration</span>
<span class="sd">    as well, including unfinished enumerations. Which is not exactly the</span>
<span class="sd">    desired behaviour.</span>

<span class="sd">    How to solve this</span>
<span class="sd">    -----------------</span>
<span class="sd">    As explained in the previous paragraphs, we can&#39;t have registerItem and</span>
<span class="sd">    finishItemRegistration on the BaseEnumeration class, so we should add them as</span>
<span class="sd">    attributes to the actual enumeration subclasses. This way we _can_ remove</span>
<span class="sd">    the methods from the class (and it&#39;s instances) at runtime.</span>

<span class="sd">    This is exactly what this metaclass does: it generates the desired methods</span>
<span class="sd">    using some method generators, and adds them as attributes on the</span>
<span class="sd">    BaseEnumeration subclasses.</span>

<span class="sd">    It does not add the methods on the BaseEnumeration type itself, so this class</span>
<span class="sd">    is (and should be) useless as-is.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">_enumeration_types</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="sd">&#39;&#39;&#39;This will store all enumerations we ever met, so we don&#39;t re-register,</span>
<span class="sd">    not even when doing imp.load_module to load an extension&#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">BaseEnumerationMeta</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>

        <span class="c">#This gets the file a class is defined in, without its extension</span>
        <span class="kn">import</span> <span class="nn">inspect</span>
        <span class="n">modfile</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">klass</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">getfile</span><span class="p">(</span><span class="n">klass</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">BaseEnumerationMeta</span><span class="o">.</span><span class="n">_enumeration_types</span><span class="p">[(</span><span class="n">modfile</span><span class="p">(</span><span class="n">ret</span><span class="p">),</span> <span class="n">name</span><span class="p">,</span> <span class="p">)]</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="s">&#39;_INTERMEDIATE_CLASS&#39;</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
                <span class="c">#If the enumeration is sealed/finished, we still need to provide</span>
                <span class="c">#dummy behaviour, since registerItem etc can be re-called on it</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">registerItem</span> <span class="o">=</span> <span class="nb">classmethod</span><span class="p">(</span><span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="bp">None</span><span class="p">)</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">finishItemRegistration</span> <span class="o">=</span> <span class="nb">classmethod</span><span class="p">(</span><span class="n">generateFinishItemRegistration</span><span class="p">())</span>

            <span class="k">return</span> <span class="n">ret</span>

        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c">#Check whether BaseEnumeration is already defined. If it isn&#39;t, we&#39;re</span>
            <span class="c">#registering BaseEnumeration itself, so the methods should not be added</span>
            <span class="n">BaseEnumeration</span>
        <span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span>

        <span class="c">#This is the case for non-final enumeration types, eg EnumerationWithValue</span>
        <span class="k">if</span> <span class="s">&#39;_INTERMEDIATE_CLASS&#39;</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c">#Add methods to the class</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">registerItem</span> <span class="o">=</span> <span class="nb">classmethod</span><span class="p">(</span><span class="n">generateRegisterItem</span><span class="p">())</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">finishItemRegistration</span> <span class="o">=</span> <span class="nb">classmethod</span><span class="p">(</span><span class="n">generateFinishItemRegistration</span><span class="p">())</span>

        <span class="n">BaseEnumerationMeta</span><span class="o">.</span><span class="n">_enumeration_types</span><span class="p">[(</span><span class="n">modfile</span><span class="p">(</span><span class="n">ret</span><span class="p">),</span> <span class="n">name</span><span class="p">,</span> <span class="p">)]</span> <span class="o">=</span> <span class="n">ret</span>

        <span class="c">#Call class._initItems</span>
        <span class="nb">getattr</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="s">&#39;_initItems&#39;</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="bp">None</span><span class="p">)()</span>

        <span class="c">#Since we can&#39;t hook enumerations on jumpscale.q directly, since &#39;q&#39;</span>
        <span class="c">#could be not initialized when the first enumeration type is created.</span>
        <span class="c">#To get around this, we use a module-global container variable which</span>
        <span class="c">#gets populated, and should be hooked onto jumpscale.j whenever</span>
        <span class="c">#applicable.</span>
        <span class="c">#</span>
        <span class="c">#For some reason, it was decided to use smallCapStarting names for</span>
        <span class="c">#enumerations registered on j.enumerators, although they&#39;re types.</span>
        <span class="c">#I guess this should be emulated here.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">enumerations</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s">&#39;Unable to register enumeration </span><span class="si">%s</span><span class="s">, name already in use&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">enumerations</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">ret</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span>

<span class="c">##workaround to be able to serialize enums</span>
<span class="k">def</span> <span class="nf">getEnumName</span><span class="p">(</span><span class="n">name</span><span class="p">):</span></div>
<div class="viewcode-block" id="getEnumName"><a class="viewcode-back" href="../../../../API/JumpScale.core.baseclasses.html#JumpScale.core.baseclasses.BaseEnumeration.getEnumName">[docs]</a>    <span class="k">return</span> <span class="n">name</span>

<span class="k">class</span> <span class="nc">BaseEnumeration</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span></div>
<div class="viewcode-block" id="BaseEnumeration"><a class="viewcode-back" href="../../../../API/JumpScale.core.baseclasses.html#JumpScale.core.baseclasses.BaseEnumeration.BaseEnumeration">[docs]</a>    <span class="sd">&#39;&#39;&#39;Base class for any enumeration-style class</span>

<span class="sd">    If you are creating a subclass of BaseEnumeration which is *not* a &#39;final&#39;</span>
<span class="sd">    class (ie representing a real-world object, just creating an BaseEnumeration</span>
<span class="sd">    type which provides some more functionality which should be subclassed as</span>
<span class="sd">    well), you should add an attribute called _INTERMEDIATE_CLASS to your</span>
<span class="sd">    intermediate class so the BaseEnumeration type system can take this into</span>
<span class="sd">    account when adding methods to final classes.</span>

<span class="sd">    Subclasses of BaseEnumeration can have a classmethod called C{_initItems}</span>
<span class="sd">    which will be called when the corresponding type is constructed. Thisj.enumerators.MessageType.UNKNOWN</span>
<span class="sd">    allows you to add items to an enumeration inside the enumeration</span>
<span class="sd">    definition, eg:</span>

<span class="sd">    &gt;&gt;&gt; class MyEnumeration(BaseEnumeration):</span>
<span class="sd">    ...     @classmethod</span>
<span class="sd">    ...     def _initItems(cls):</span>
<span class="sd">    ...         cls.registerItem(&#39;foo&#39;)</span>
<span class="sd">    ...         cls.registerItem(&#39;bar&#39;)</span>
<span class="sd">    ...         cls.finishItemRegistration()</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; print MyEnumeration.FOO</span>
<span class="sd">    foo</span>
<span class="sd">    &gt;&gt;&gt; print MyEnumeration.BAR</span>
<span class="sd">    bar</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c">#Set type generator so registerItem and finishItemRegistration are added</span>
    <span class="c">#if necessary</span>
    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">BaseEnumerationMeta</span>

    <span class="k">def</span> <span class="nf">getByName</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">itemname</span><span class="p">):</span>
<div class="viewcode-block" id="BaseEnumeration.getByName"><a class="viewcode-back" href="../../../../API/JumpScale.core.baseclasses.html#JumpScale.core.baseclasses.BaseEnumeration.BaseEnumeration.getByName">[docs]</a>        <span class="sd">&#39;&#39;&#39;Get enumeration value based on item name as provided to L{registerItem}&#39;&#39;&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_pm_enumeration_items</span><span class="p">[</span><span class="n">itemname</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s">&#39;Enumeration </span><span class="si">%s</span><span class="s"> got no item with name </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> \
                    <span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">itemname</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">getByLevel</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span></div>
<div class="viewcode-block" id="BaseEnumeration.getByLevel"><a class="viewcode-back" href="../../../../API/JumpScale.core.baseclasses.html#JumpScale.core.baseclasses.BaseEnumeration.BaseEnumeration.getByLevel">[docs]</a>        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Get enumeration value based on item level as provided to L{registerItem}</span>
<span class="sd">        only works for enumeration where level has been defined</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_pm_level2name</span><span class="p">[</span><span class="n">level</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s">&#39;Enumeration </span><span class="si">%s</span><span class="s"> got no item with level </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> \
                    <span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">level</span><span class="p">))</span>
        
    <span class="n">getByName</span><span class="o">.</span><span class="n">_pm_enumeration_hidden</span> <span class="o">=</span> <span class="bp">True</span></div>
    <span class="n">getByName</span> <span class="o">=</span> <span class="nb">classmethod</span><span class="p">(</span><span class="n">getByName</span><span class="p">)</span>
    <span class="n">getByLevel</span> <span class="o">=</span> <span class="nb">classmethod</span><span class="p">(</span><span class="n">getByLevel</span><span class="p">)</span>



    <span class="c">##workaround to be able to serialize enums</span>
    <span class="k">def</span> <span class="nf">__reduce_ex__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">prot</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">getEnumName</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),))</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pm_enumeration_name</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pm_enumeration_name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_pm_enumeration_name</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<div class="viewcode-block" id="BaseEnumeration.check"><a class="viewcode-back" href="../../../../API/JumpScale.core.baseclasses.html#JumpScale.core.baseclasses.BaseEnumeration.BaseEnumeration.check">[docs]</a>        <span class="sd">&#39;&#39;&#39;Type check for this enumeration type</span>

<span class="sd">        This method checks whether the provided argument value is an instance</span>
<span class="sd">        of this enumeration type and is registered on it.</span>

<span class="sd">        @param value: Value to validate</span>
<span class="sd">        @type value: BaseEnumeration subclass</span>
<span class="sd">        @returns: Whether value is a valid enumeration item</span>
<span class="sd">        @rtype: bool</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="n">value</span> <span class="ow">is</span> <span class="n">cls</span><span class="o">.</span><span class="n">_pm_enumeration_items</span><span class="p">[</span><span class="n">value</span><span class="o">.</span><span class="n">_pm_enumeration_name</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">printdoc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span></div>
<div class="viewcode-block" id="BaseEnumeration.printdoc"><a class="viewcode-back" href="../../../../API/JumpScale.core.baseclasses.html#JumpScale.core.baseclasses.BaseEnumeration.BaseEnumeration.printdoc">[docs]</a>        <span class="c">#@todo get this to work</span>
        <span class="k">print</span><span class="p">(</span><span class="n">__doc__</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">EnumerationWithValue</span><span class="p">(</span><span class="n">BaseEnumeration</span><span class="p">):</span></div></div>
<div class="viewcode-block" id="EnumerationWithValue"><a class="viewcode-back" href="../../../../API/JumpScale.core.baseclasses.html#JumpScale.core.baseclasses.BaseEnumeration.EnumerationWithValue">[docs]</a>    <span class="sd">&#39;&#39;&#39;Enumeration base type providing separation between item name and value</span>

<span class="sd">    Since some names (which are invalid Python identifiers) are forbidden as</span>
<span class="sd">    enumeration item name, this class provides separation between item names</span>
<span class="sd">    and item value (which is the value returned by __str__, equal to name in</span>
<span class="sd">    the basic Enumeration type).</span>

<span class="sd">    Next to this, it offers a &#39;doc&#39; attribute which is returned by __repr__.</span>

<span class="sd">    Example use case: the VirtualboxNicType enumeration contains an item which</span>
<span class="sd">    should be called &#39;82540EM&#39;. This is an invalid identifier, so it had to be</span>
<span class="sd">    renamed to &#39;I82540EM&#39; as name. We still want to provide the original value</span>
<span class="sd">    as well though.</span>
<span class="sd">    Next to this, &#39;82540EM&#39; is not easy to understand, so we want to represent</span>
<span class="sd">    the item as &#39;Intel PRO/1000MT Desktop&#39; to the end-user, which is the doc</span>
<span class="sd">    property displayed by __repr__.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">_INTERMEDIATE_CLASS</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">value</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Initialize a new instance</span>

<span class="sd">        @param value: Custom value, returned by __str__</span>
<span class="sd">        @type value: string</span>
<span class="sd">        @param doc : Human readable representation or item documentation</span>
<span class="sd">        @type doc: string</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">doc</span> <span class="o">=</span> <span class="n">doc</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Return the item value&#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Return the item documentation, a human-readable representation</span>

<span class="sd">        This returns the doc attribute by default, or the item value if no</span>
<span class="sd">        documentation is provided.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">doc</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">EnumerationProperty</span><span class="p">(</span><span class="nb">property</span><span class="p">):</span></div>
<div class="viewcode-block" id="EnumerationProperty"><a class="viewcode-back" href="../../../../API/JumpScale.core.baseclasses.html#JumpScale.core.baseclasses.BaseEnumeration.EnumerationProperty">[docs]</a>    <span class="sd">&#39;&#39;&#39;Specialized descriptor for Enumeration class attributes</span>

<span class="sd">    This descriptor (think &#39;property&#39;) can be used when the property value</span>
<span class="sd">    should be an item of an enumeration. The Enumeration type should be</span>
<span class="sd">    provided to the constructor, after which automatic type checking is</span>
<span class="sd">    performed when trying to set the attribute, and string conversion is done</span>
<span class="sd">    behind the scenes.</span>

<span class="sd">    This string conversion makes sure only the item name is stored as an</span>
<span class="sd">    attribute on the class instance, not the enumeration item itself. This</span>
<span class="sd">    removes several potential pitfalls when serializing (pickling) the</span>
<span class="sd">    instance.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">enumtype</span><span class="p">,</span> <span class="n">fget</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fset</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fdel</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Create a new C{EnumerationProperty} instance</span>

<span class="sd">        The enumtype argument should be the Enumeration type the values</span>
<span class="sd">        assigned to this descriptor should be items of.</span>

<span class="sd">        Other arguments correspond to the arguments of the standard property</span>
<span class="sd">        descriptor.</span>

<span class="sd">        @param enumtype: Enumeration type argument values should be items of</span>
<span class="sd">        @type enumtype: type</span>
<span class="sd">        @param fget: See property.fget</span>
<span class="sd">        @type fget: callable</span>
<span class="sd">        @param fset: See property.fset</span>
<span class="sd">        @type fset: callable</span>
<span class="sd">        @param fdel: See property.fdel</span>
<span class="sd">        @type fdel: callable</span>
<span class="sd">        @param doc: See property.doc</span>
<span class="sd">        @type doc: string</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="nb">property</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fget</span><span class="o">=</span><span class="n">fget</span><span class="p">,</span> <span class="n">fset</span><span class="o">=</span><span class="n">fset</span><span class="p">,</span> <span class="n">fdel</span><span class="o">=</span><span class="n">fdel</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">doc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_enumtype</span> <span class="o">=</span> <span class="n">enumtype</span>

    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">objtype</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="nb">property</span><span class="o">.</span><span class="n">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">objtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enumtype</span><span class="o">.</span><span class="n">getByName</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enumtype</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Property should be set to an item of the </span><span class="si">%s</span><span class="s"> enumeration&#39;</span> <span class="o">%</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_enumtype</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>

        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">_pm_enumeration_name</span>

        <span class="nb">property</span><span class="o">.</span><span class="n">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index"
             >index</a></li>
        <li><a href="../../../../index.html">Jumpscale Doc 7.0 documentation</a> &raquo;</li>
          <li><a href="../../../index.html" >Module code</a> &raquo;</li>
          <li><a href="../baseclasses.html" >JumpScale.core.baseclasses</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
    </div>
  </body>
</html>